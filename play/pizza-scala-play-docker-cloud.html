<!DOCTYPE html>
<html>
<head>
	<title>Pizza in the cloud, with Scala, Play and Docker Cloud</title>
	<link rel="shortcut icon" href="/favicon.ico">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
   <meta http-equiv="Keywords" content="scala,play,framework,docker,cloud,pizza"/>
   <meta http-equiv="description" content="Pizza in the cloud. Using Scala and Play Framework to create a application hosted with Docker Cloud"/>
   <meta name="viewport" content="initial-scale=0.8"/>
   <link href="../android/docs.css" rel="stylesheet" type="text/css" />
   <link href="../docker/docs.css" rel="stylesheet" type="text/css" />
   <link href="../git/docs.css" rel="stylesheet" type="text/css" />
   <link href="../letsencrypt/docs.css" rel="stylesheet" type="text/css" />
   <link href="docs.css" rel="stylesheet" type="text/css" />
   <style>

   </style>
   <script type="text/javascript">
     var _gaq = _gaq || [];
     _gaq.push(['_setAccount', 'UA-281408-1']);
     _gaq.push(['_trackPageview']);

     (function() {
      if(location.host!='localhost'){
       var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
       ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
       var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      }
     })();
   </script>
</head>
<body>

   <div id="ocean">
      <div id="ship">
         <div id="toprighter">
            <a href="http://creativecommons.org/licenses/by-sa/2.5/"><img
               src="/images/cc-by-sa-small.png" alt="cc by-sa"
               title="Creative Commons Attributions-ShareAlike"
               border="0" align="right" /></a>
            <a href="http://flurdy.com"><img src="/images/flurdy_warped_dual_small.png" border="0" align="right" alt="flurdy" title="" class="flurdySmall"/></a>
         </div>
         <header>
            <h1>
               Pizza in the cloud
            </h1>
            <h3>
               with Scala, Play and Docker Cloud
            </h3>
            <h4>
               How  to create a pizza ordering service application
               using Scala and the Play Framework.
               Wrap it in a Docker container and deploy it with Docker Cloud.
            </h4>
         </header>
         <nav id="lookout">
            <ul class="horizontal">
               <li><a href="http://flurdy.com">flurdy</a></li>
               <li><a href="http://twitter.com/flurdy">@flurdy</a></li>
               <li><a href="http://blog.flurdy.com">blog</a></li>
               <li><a href="http://shirts.flurdy.com">shirts</a></li>
               <li><a href="http://www.eray.uk">hire</a></li>
               <li><a href="/docs/">more docs</a></li>
            </ul>
         </nav>
         <div id="jib">
            Started: November 2016.
            Last updated: 6th Dec 2016.
         </div>

         <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
         <!-- flurdy.com play docker cloud leaderboard -->
         <ins class="adsbygoogle"
              style="display:inline-block;width:728px;height:90px"
              data-ad-client="ca-pub-7805345644641760"
              data-ad-slot="2454112886"></ins>
         <script>
         (adsbygoogle = window.adsbygoogle || []).push({});
         </script>

        <div id="starboard">
          <nav>
               <h5>Contents</h5>
               <ul>
                  <li><a href="#dejavue">Deja-Vue</a></li>
                  <li><a href="#environment">Build&nbsp;environment</a></li>
                  <li><a href="#play">Play scaffold</a></li>
                  <li><a href="#docker">Dockerise</a></li>
                  <li>
                     <a href="#pizza">Pizzeria</a>
                     <ul>
                        <li><a href="#pizza_menu">Show menu</a></li>
                        <li><a href="#pizza_order">Order pizza</a></li>
                        <li><a href="#pizza_confirm">Confirm order</a></li>
                     </ul>
                  </li>
                  <li><a href="#persist">Persist</a></li>
                  <li>
                     <a href="#docker_cloud">Docker&nbsp;Cloud</a>
                     <ul>
                        <li><a href="#docker_cloud_repository">Repository</a></li>
                        <li><a href="#docker_cloud_node">Node(s)</a></li>
                        <li><a href="#docker_cloud_service">Service</a></li>
                     </ul>
                  </li>
                  <li><a href="#alt">Alternatives</a></li>
                  <li><a href="#contact">Feedback</a></li>
                  <li><a href="#refrences">Refrences</a></li>
               </ul>
              </nav>
            <div class="shirts">
               <div class="shirt">
                  <a href="http://flurdy.spreadshirt.com/no-i-will-not-fix-your-computer-A3797075/customize/color/2"><img id="wontfix"
                     src="//image.spreadshirt.com/image-server/v1/products/110865579/views/1,width=280,height=280.png/no-i-will-not-fix-your-computer-1850.png"
                      alt="wont fix" title="No, I will not fix your computer"/></a>
               </div>
               <div class="link"><a href="http://shirts.flurdy.com">shirts.flurdy.com</a></div>
            </div>
         </div>

<div id="cargo">

   <div id="dejavue-box" class="paragraph">
      <a name="dejavue"></a>
      <h3>Deja-Vue</h3>
      <p>
         My pizza service analogy works well as an example as it covers showing pages,
         posting forms, and reading changed data. And I have over time written several howtos that use the pizza service analogy,
         the <a href="https://www.playframework.com">Play framework</a>, and hosting with various cloud providers:
      </p>
      <ul >
         <li>
            <a href="/docs/herokuplay/play1.html">Play! &amp; Heroku (develop quickly &amp; deploy easily to the cloud)</a>.<br/>
            My first pizza app, using Play v1.2 and <a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a>.
             And deploying to <a href="http://www.heroku.com">Heroku</a>.
         </li>
         <li>
            <a href="/docs/herokuplay/play2.html">Play! 2.0 + Scala + Heroku (develop even quicker &amp; deploy easily to the cloud)</a>.<br/>
            This time with Play v2.0 and <a href="http://www.scala-lang.org">Scala</a>.
         </li>
         <li>
            <a href="/docs/docker/docker_compose_machine_swarm_cloud.html">Docker with Compose, Machine and Swarm, easy steps from localhost to cloud providers</a>.<br/>
            Using <a href="https://www.docker.com/products/docker-compose">Docker Compose</a> to orchestrate a pizza ordering frontend with Play v2.3, a <a href="http://spray.io">Spray</a> backend with a <a href="https://www.postgresql.org">PostgreSQL</a> database.
         </li>
      </ul>
   </div>

   <div class="paragraph">
      <a name="environment"></a>
      <h3>Build environment</h3>

      <div class="paragraph">
         <h4>Java and Scala</h4>
         <p>
            You do need Java JDK v8 installed. Scala however can be installed but the build tool below will download a Scala SDK instance so not neccessary.
            You can use <a href="http://openjdk.java.net">OpenJDK</a> or <a href="http://oracle.com">Oracle</a>'s own JDK version.
         </p>

         <h4>Oracle JDK</h4>
         <p>
            For <a href="http://www.apple.com/uk/macos/">macOS</a> go to <a href="http://www.oracle.com/technetwork/java/javase/downloads/">Oracle's JDK page</a>,
            choose the latest JDK8 version, accept the license, download and run the <em>dmg</em> file.
         </p>
         <p>
            For <a href="http://ubuntu.com">Ubuntu</a> users <a href="http://www.webupd8.org/2012/09/install-oracle-java-8-in-ubuntu-via-ppa.html">install Oracle JDK8 via apt-get</a>:
         </p>
         <code>
            sudo add-apt-repository ppa:webupd8team/java;<br/>
            sudo apt-get update;<br/>
            sudo apt-get install oracle-java8-installer;<br/>
            sudo apt-get install oracle-java8-set-default
         </code>
         <h4>OpenJDK</h4>
         <p>
            For macOS use <a href="http://brew.sh">Homebrew</a>:
         </p>
         <code>brew cask install java</code>
         <p>
            On Ubuntu v14.04 &amp; v12.04,
            you need to add a <a href="">PPA</a>,
            for v14.10 and later its in the standard repositories.
         </p>
         <code>
            sudo add-apt-repository ppa:openjdk-r/ppa;<br/>
            sudo apt-get update;
         </code>
         <p>
            Then for all Ubuntu versions:
         </p>
         <code>
            sudo apt-get install openjdk-8-jdk
         </code>
         <p>
            Then also on Ubuntu run and choose JDK 8 for both of these:
         </p>
         <code>
            sudo update-alternatives --config java
         </code>
         <code>
            sudo update-alternatives --config javac
         </code>
      </div>

      <div class="paragraph">
         <h4>Activator</h4>
         <p>
            Download and install <a href="https://www.lightbend.com/activator/download">Activator</a>, <a href="https://www.lightbend.com">Lightbend</a>'s (n√© Typesafe) extension of <a href="http://www.scala-sbt.org/">SBT</a>, the near default Scala build tool.
            Activator includes a UI which you do not need,
            but does include the handy <em>new</em> command to scaffold Play and <a href="http://akka.io/">Akka</a> applications.
         </p>
         <p>
            Activator comes in two flavours: <em>full</em> and <em>mini</em>. <em>Full</em> includes common dependencies for Play and Akka. <em>Full</em> will save you a little time initially, but soon the dependencies versions will move along and you have to download them all like <em>mini</em> via SBT's use of <a href="http://ant.apache.org/ivy/">Ivy</a> anyway.
         </p>
         <p>
            On macOS:
         </p>
         <code>brew install typesafe-activator</code>
         <p>
            On Linux download and extract the Zip:
         </p>
         <code class="wide">
            wget
            <span class="tiny-code">https://downloads.typesafe.com/typesafe-activator/<em>1.3.12</em>/typesafe-activator-<em>1.3.12</em>-minimal.zip;</span><br/>
            unzip typesafe-activator-<em>1.3.12</em>-minimal.zip;<br/>
            sudo mv activator-<em>1.3.12</em>-minimal /opt/activator
         </code>
         <p>
            then add <em>/opt/activator/bin</em> to your <em>$PATH</em> environment variable.
         </p>
      </div>
      <div class="paragraph">
         <h4>SBT</h4>
         <p>
            I recommend also installing SBT, as 99% of the time you don't need the extra cruft of Activator.
            There are other Scala build tools such as <a href="https://maven.apache.org/">Maven</a> and <a href="https://gradle.org/">Gradle</a>,
            but there is little reason to use those with Scala and again you will painfully swim against the current of 99% of projects and companies that defaults to SBT.
         </p>
         <p>
            On macOS:
         </p>
         <code>brew install sbt</code>
         <p>
            Or on Ubuntu/<a href="https://www.debian.org/">debian</a> <a href="http://www.scala-sbt.org/0.13/docs/Installing-sbt-on-Linux.html">install SBT via apt-get</a>.
         </p>
         <code class="wide">
            echo "deb https://dl.bintray.com/sbt/debian /" | \<br/>
            &nbsp;sudo tee -a /etc/apt/sources.list.d/sbt.list;<br/>
            sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 \<br/>
            &nbsp;--recv 2EE0EA64E40A89B84B2DF73499E82A75642AC823;<br/>
            sudo apt-get update;<br/>
            sudo apt-get install sbt
         </code>
      </div>
   </div>

   <div class="paragraph">
      <a name="play"></a>
      <h3>Play scaffold</h3>
      <p>
         Since v2.4 Play has used <a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>, which is the most significant difference
         in my pizza ordering application compared to my previous iterations.
         <a href="https://www.playframework.com/documentation/2.5.x/ScalaDependencyInjection">Play's choice of run time DI</a> with <a href="https://github.com/google/guice">Guice</a>
         goes against my strong preference for
         <a href="https://www.playframework.com/documentation/2.5.x/ScalaCompileTimeDependencyInjection">compile time DI</a>,
         but it is futile to swim against the current.
      </p>

      <div class="paragraph">
         <h4>Scaffold</h3>
         <p>
            Create the new application:
         </p>
         <code>activator new pizzeria</code>
         <p>
            Choose option 6, the <em>play-scala</em> option.
         </p>
         <p>
            You now have a basic play application folder structure inside <em>pizzeria</em>:
         </p>
         <ul>
            <li>
               <em>conf/build.sbt</em>
               is where you define your libraries, versions and name of the application.
            </li>
            <li>
               <em>conf/routes</em>
               is where you define the routing of request's url paths to the controllers.
            </li>
            <li>
               <em>app/controllers/HomeController</em>
               is one example controller that currently shows the home page.
            </li>
            <li>
               <em>app/views/main.scala.html</em>
               is the shared common template for most views.
            </li>
            <li>
               <em>app/views/index.scala.html</em>
               is the example template for the home page content.
            </li>
            <li>
               <em>public/stylesheets/main.css</em>
               is the default style sheet.
               Feel free to rename or add more.
            </li>
         </ul>
      </div>
      <div class="paragraph">
         <h4>Download the internet</h3>
         <p>
            Since we used the mini flavour of Activator we need to download all the dependencies.
         </p>
         <p>
            Launch Activator or SBT (and make some tea):
         </p>
         <code>sbt</code>
         <p>
            Compile and test the code (drink the tea and fetch some biscuits)
         </p>
         <code class="app">
            ;compile;test
         </code>
         <p>
            Then run the application (and make some more tea)
         </p>
         <code class="app">
            run
         </code>
         <p>
            Thankfully you will not need to download the internet from now on,
            as your local <em>~/.ivy2</em> folder is now enormous.
         </p>
         <p>
            Since we haven't changed anything this should all work,
            and the application will now be available on the default port of 9000.
         </p>
         <code>curl localhost:9000</code>
         <p>
            Press <em>ctrl+d</em> to stop. Then exit SBT:
         </p>
         <code class="app">exit</code>
         <p>
            You now have a working scaffold.
            Note a shortcut to run the app:
         </p>
         <code>sbt run</code>
      </div>
   </div>

   <div class="paragraph">
      <a name="docker"></a>
      <h3>Dockerise</h3>

      <div class="paragraph">
         <h4>Install Docker</h4>
         <p>
            On macOS you can install <a href="https://www.docker.com/products/docker">Docker</a> via Brew, which I used to do.
            But the "new" <a href="https://docs.docker.com/docker-for-mac/">Docker for Mac</a> is a better choice.
            Download and run the <a href="https://download.docker.com/mac/stable/Docker.dmg">dmg</a> file.
            Launch the Docker app via <a href="https://en.wikipedia.org/wiki/Launchpad_(OS_X)">Launchpad</a>.
         </p>
         <p>
            For Linux it <a href="https://docs.docker.com/engine/installation/linux/">depends on the distrobution</a>, for <a href="https://docs.docker.com/engine/installation/linux/ubuntulinux/">Ubuntu 16.04</a>:
         </p>
         <code class="wide">
            sudo apt-get install apt-transport-https ca-certificates;<br/>
            sudo apt-key adv \<br/>
            &nbsp;--keyserver hkp://ha.pool.sks-keyservers.net:80 \<br/>
            &nbsp;--recv-keys 58118E89F3A912897C070ADBF76221572C52609D;<br/>
            echo "deb https://apt.dockerproject.org/repo ubuntu-xenial main" | \<br/>
            &nbsp;sudo tee /etc/apt/sources.list.d/docker.list;<br/>
            sudo apt-get update;<br/>
            sudo apt-get install linux-image-extra-$(uname -r) \<br/>
            &nbsp;linux-image-extra-virtual;<br/>
            sudo apt-get install docker-engine;<br/>
            sudo service docker start
         </code>
      </div>


      <div class="paragraph">
         <h4>Dockerfile</h4>
         <p>
            You have a few options of how you build your images.
            Mostly due to relatively slowness of downloading all Ivy dependencies from scratch on every build.
         </p>
         <p>
            You can build the <a href="https://en.wikipedia.org/wiki/JAR_(file_format)">jar</a> file outside of Docker.
            Then just add the jar or <em>target/stage</em> folder to the Dockerfile. This is result in very fast Docker image builds,
            but adds another step that is just as slow before it.
         </p>
         <p>
            For that you either build manually in the project folder via <em>sbt package</em> or <em>sbt stage</em> (for Play apps).
         </p>
         <p>
            Or via a build/<a href="https://en.wikipedia.org/wiki/Continuous_integration">continuous integration</a> server that
            uploads it to a <a href="https://en.wikipedia.org/wiki/Software_repository">Maven/Ivy repository</a>.
         </p>
         <p>
            Or you build it inside Docker.
         </p>
         <p>
            Either on every build, this is the least complicated method but also very, very slow.
            This is the method we will use in this document.
         </p>
         <p>
            Or you depend on a base image with all the dependencies preload in <em>~/.ivy2</em>.
            Similar to <a href="https://github.com/flurdy/Dockerfiles/tree/master/play-framework-base">my play-framework-base</a>.
            You then extend your Dockerfile from this base image.
            Note the versions of the dependencies in the base and your project must match for it to be of use.
         </p>
         <p>
            Create a <em>Dockerfile</em> in the root folder.
            This will use my <a href="https://github.com/flurdy/Dockerfiles/tree/master/play-framework">my play-framework image</a>,
            so the default dependencies for <em>Play</em> is already part of the image but not any other dependencies.
         </p>
         <code class="file wide">
            FROM flurdy/play-framework:2.5.10-alpine<br/>
            <br/>
            MAINTAINER Ivar Abrahamsen <@flurdy><br/>
            <br/>
            COPY conf /etc/app/<br/>
            <br/>
            ADD . /opt/build/<br/>
            <br/>
            WORKDIR /opt/build<br/>
            <br/>
            RUN /opt/activator/bin/activator clean stage &amp;&amp; \<br/>
               &nbsp;&nbsp;rm -f target/universal/stage/bin/*.bat &amp;&amp; \<br/>
               &nbsp;&nbsp;mv target/universal/stage/bin/* target/universal/stage/bin/app &amp;&amp; \<br/>
               &nbsp;&nbsp;mv target/universal /opt/app &amp;&amp; \<br/>
               &nbsp;&nbsp;ln -s /opt/app/stage/logs /var/log/app &amp;&amp; \<br/>
               &nbsp;&nbsp;rm -rf /opt/build &amp;&amp; \<br/>
               &nbsp;&nbsp;rm -rf /root/.ivy2<br/>
            <br/>
            WORKDIR /opt/app<br/>
            <br/>
            ADD . /opt/build/<br/>
            <br/>
            ENTRYPOINT ["/opt/app/stage/bin/app"]<br/>
            <br/>
            EXPOSE 9000
         </code>
      </div>

      <div class="paragraph">
         <h4>Build Docker Image</h4>
         <p>
            Build the image and name it <em>pizzeria</em>:
         </p>
         <code>docker build -t pizzeria .</code>
         <p>
            This will take a while. You will need to get more than a cup of tea.
         </p>
         <p>
            Run the new image and map the port to <em>9020</em>.
         </p>
         <code>docker run -ti --rm -p 9000:9020 pizzeria:latest</code>
         <p>
            In another terminal window:
         </p>
         <code>curl localhost:9020</code>
      </div>
   </div>

   <div class="paragraph">
      <a name="pizza"></a>
      <h3>Pizzeria service</h3>
      <p>
         Lets create the actual pizzeria service.
         We will create a normal landing page that in our case shows the pizza menu and order form.
         We will have a <a href="https://en.wikipedia.org/wiki/POST_(HTTP)">POST</a> endpoint to send our order to,
         and a confirmation page to confirm our pizza order has been received.
      </p>
      <p>
         Though first lets remove some parts we are not using in this application.
         (of course in your future applications you may use these, so be aware of them)
      </p>
      <code>
         rm -f app/controllers/AsyncController.scala;<br/>
         rm -f app/controllers/CountController.scala;<br/>
         rm -rf app/filters app/services;<br/>
         rm -f app/Filters.scala app/Module.scala;<br/>
         rm -rf bin libexec;<br/>
         <!-- rm -f public/javascripts/hello.js;<br/> -->
         rm -rf test
      </code>

      <p>
			Note: There is an example <a href="http://github.com/flurdy/pizzeria">pizzeria project on my Github</a>.
      </p>

      <p>
         In the project's <em>build.sbt</em> file lets remove some dependencies we won't need in this example (<em>cache, ws, scalatest</em>),
         keeping <em>jdbc</em> as we will need that later.
         And also add a hack with <em>devnull</em> to support docker restarts.
      </p>
      <code><em>vi</em> build.sbt</code>
      <code class="file wide">
         name := """pizzeria"""<br/>
         <br/>
         version := "<em>1.0-SNAPSHOT</em>"<br/>
         <br/>
         lazy val root = (project in file(".")).enablePlugins(PlayScala)<br/>
         <br/>
         scalaVersion := "<em>2.11.8</em>"<br/>
         <br/>
         libraryDependencies ++= Seq(<br/>
           <em>&nbsp;&nbsp;jdbc</em><br/>
         )<br/>
         <br/>
         <em>javaOptions in Universal ++= Seq(<br/>
           &nbsp;&nbsp;"-Dpidfile.path=/dev/null"<br/>
         )
         </em>
      </code>

      <div class="paragraph">
         <a name="pizza_menu"></a>
         <h4>Show menu</h4>
         <p>
            Lets edit the routes file.
            We will remove the references to <em>Async</em>, <em>Home</em> and <em>CountControllers</em>.
            And add a PizzaController.
            Open <em>conf/routes</em> in your editor of choice.
         </p>
         <code><em>vi</em> conf/routes</code>
         <code class="file wide">
            # Routes<br/>
            # ~~~~<br/>
            <br/>
            GET&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            controllers.PizzaController.showMenu<br/>
            <br/>
            GET&nbsp;&nbsp;&nbsp;/assets/*file&nbsp;&nbsp;&nbsp;&nbsp;
            controllers.Assets.versioned(path="/public", file: Asset)
         </code>
         <p>
            You can cheat a little by just renaming <em>HomeController</em> to <em>PizzaController</em>,
            then editing it.
         </p>
         <code>
            mv -f app/controllers/HomeController.scala \<br/>
            &nbsp;&nbsp;app/controllers/PizzaController.scala;<br/>
            <em>vi</em> app/controllers/PizzaController.scala
         </code>
         <p>
            Lets rename the class, and then rename the <em>index</em> function to <em>showMenu</em>,
            and return the <em>pizzamenu</em> template.
         </p>
         <code class="file wide">
            package controllers<br/>
            <br/>
            import javax.inject._<br/>
            import play.api._<br/>
            import play.api.mvc._<br/>
            <br/>
            @Singleton<br/>
            class <strong>PizzaController</strong> @Inject() () extends Controller {<br/>
            <br/>
            &nbsp;&nbsp;def showMenu = Action {<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;Ok(views.html.pizzamenu)<br/>
            &nbsp;&nbsp;}<br/>
            <br/>
            }
         </code>
         <p>
            Again we can cheat by renaming the <em>index</em> template,
            and removing some cruft.
         </p>
         <code>
            mv -f app/views/index.scala.html app/views/pizzamenu.scala.html;<br/>
            <em>vi</em> app/views/pizzamenu.scala.html
         </code>
         </p>
         <code class="file wide">
            @()<br/>
            <br/>
            @main("Pizza Menu") {<br/>
            <br/>
               &nbsp;&nbsp;&lt;h1&gt;Pizza Menu&lt;/h1&gt;<br/>
            <br/>
            }
         </code>
         <p>
            Running the app,
            and testing it in another terminal or browser should display the "Pizza Menu" headline.
         </p>
         <code>sbt run</code>
         <code>curl localhost:9000</code>
         <p>
            Ok that is nice, but there is still no actual pizzas shown!
            Lets create the domain object:
         </p>
         <code>
            mkdir app/models;<br/>
            touch app/models/pizza.scala;<br/>
            <em>vi</em> app/models/pizza.scala
         </code>
         <code class="file wide">
            package models<br/>
            <br/>
            case class Pizza(name: String)
         </code>
         <p>
            And a repository lookup,
            this could query a database,
            or use some connector/adapter to talk to some middleware or backend services.
         </p>
         <code>
            mkdir app/repositories;<br/>
            touch app/repositories/PizzaRepository.scala;<br/>
            <em>vi</em> app/repositories/PizzaRepository.scala
         </code>
         <code class="file wide">
            package repositories<br/>
            <br/>
            import com.google.inject.ImplementedBy<br/>
            import javax.inject.Inject</br>
            import play.api.libs.concurrent.Execution.Implicits._</br>
            import scala.concurrent.Future<br/>
            import models._<br/>
            <br/>
            <br/>
            @ImplementedBy(classOf[DefaultPizzaRepository])<br/>
            trait PizzaRepository {<br/>
            <br/>
            &nbsp;&nbsp;def findPizzas() = Future { <br/>
            &nbsp;&nbsp;&nbsp;&nbsp;List( Pizza("Hawaii"), Pizza("Pepperoni") )<br/>
            &nbsp;&nbsp;}<br/>
            <br/>
            }<br/>
            <br/>
            class DefaultPizzaRepository @Inject() () extends PizzaRepository
         </code>
         <p>
            The <em>ImplementedBy</em> and <em>Inject</em> is the additional cruft required by the <em>Guice</em>
            runtime dependency injection.
            Lets inject the repository into the pizza controller:
         </p>
         <code><em>vi</em> app/controllers/PizzaController.scala</code>
         <code class="file wide">
            package controllers<br/>
            <br/>
            import javax.inject._<br/>
            import play.api._<br/>
            <em>import play.api.libs.concurrent.Execution.Implicits._</em><br/>
            import play.api.mvc._<br/>
            <em>import repositories._</em><br/>
            <br/>
            @Singleton<br/>
            class PizzaController @Inject() (<em>val pizzaRepository: PizzaRepository</em>)<br/>
            extends Controller {<br/>
            <br/>
            &nbsp;&nbsp;def showMenu = Action<em>.async</em> {<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;<em>pizzaRepository.findPizzas().map{ pizzas =&gt;</em><br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ok(views.html.pizzamenu(<em>pizzas</em>))<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;<em>}</em><br/>
            &nbsp;&nbsp;}<br/>
            <br/>
            }
         </code>
         <p>
            You will notice the <em>.async</em> postfix to the <em>Action</em>.
            This means this will return a future of result, so not blocking, and is because
            the call to the repository returns a future as well.
         </p>
         <p>
            We need to modify the pizza menu view as we now pass in a list of pizzas.
         </p>
         <code>
            <em>vi</em> app/views/pizzamenu.scala.html
         </code>
         </p>
         <code class="file wide">
            @(<em>pizzas: List[Pizza]</em>)<br/>
            <br/>
            @main("Pizza Menu") {<br/>
            <br/>
               &nbsp;&nbsp;&lt;h1&gt;Pizza Menu&lt;/h1&gt;<br/>
               <br/><em>
               &nbsp;&nbsp;&lt;ul&gt;<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;@for(pizza &lt;- pizzas){<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pizza: @pizza.name<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
               &nbsp;&nbsp;&lt;/ul&gt;</em><br/>
            <br/>
            }
         </code>
         <p>
            This should now list the pizzas in the application:
         </p>
         <code>sbt run</code>
         <code>curl localhost:9000</code>
      </div>

      <div class="paragraph">
         <a name="pizza_order"></a>
         <h4>Order pizza</h4>
         <p>
            Now lets order the pizza!
         </p>
         <p>
            First lets modify the menu view.
         </p>
         <code><em>vi</em> app/views/pizzamenu.scala.html</code>
         <code class="file wide">
            @(pizzas: List[Pizza])<br/>
            <br/>
            <em>@import helper._</em><br/>
            <br/>
            @main("Pizza Menu") {<br/>
            <br/>
               &nbsp;&nbsp;&lt;h1&gt;Pizza Menu&lt;/h1&gt;<br/>
               <br/>
               &nbsp;&nbsp;&lt;ul&gt;<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;@for(pizza &lt;- pizzas){<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>@form(action=routes.controllers.PizzaController.orderPizza){</em><br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pizza: @pizza.name<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&lt;button type="submit"&gt;order&lt;/button&gt;</em><br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>&lt;input type="hidden" name="pizza.name" value="@pizza.name"/&gt;</em><br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>}</em><br/>
               &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
               &nbsp;&nbsp;&lt;/ul&gt;<br/>
            <br/>
            }
         </code>
         <p>
            Then reflect the new <em>orderPizza</em> call in the routes file:
         </p>
         <code><em>vi</em> conf/routes</code>
         <code class="file wide">
            # Routes<br/>
            # ~~~~<br/>
            <br/>
            GET&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            controllers.PizzaController.showMenu<br/>
            <em>POST&nbsp;&nbsp;/order&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            controllers.PizzaController.orderPizza</em><br/>
            <br/>
            GET&nbsp;&nbsp;&nbsp;/assets/*file&nbsp;&nbsp;&nbsp;&nbsp;
            controllers.Assets.versioned(path="/public", file: Asset)
         </code>
         <p>
            And create the <em>orderPizza</em> function in the pizza controller to simple return a success page.
         </p>
         <code><em>vi</em> app/controllers/PizzaController.scala</code>
         <code class="file wide">
            .....<br/>
            <br/>
            &nbsp;&nbsp;def orderPizza = Action {<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;Ok<br/>
            &nbsp;&nbsp;}<br/>
            <br/>
            .....
         </code>
         <p>
            You can test the order button now, it should respond in a blank success page.
         </p>
         <p>
            When ready lets create a pizza order domain object in our models file:
         </p>
         <code>
            <em>vi</em> app/models/pizza.scala
         </code>
         <code class="file wide">
            case class PizzaOrder(id: Option[Long], pizza: Pizza)
         </code>
         <p>
            And in the controller a <a href="https://playframework.com/documentation/2.5.x/ScalaForms">form mapping</a> transformer.
         </p>
         <code><em>vi</em> app/controllers/PizzaController.scala</code>
         <code class="file wide">
            package controllers<br/>
            <br/>
            import javax.inject._<br/>
            import play.api._<br/>
            <em>import play.api.data._<br/>
            import play.api.data.Forms._</em><br/>
            import play.api.libs.concurrent.Execution.Implicits._<br/>
            import play.api.mvc._<br/>
            <em>import scala.concurrent.Future</em><br/>
            <em>import models._</em><br/>
            import repositories._<br/>
            <br/>
            @Singleton<br/>
            class PizzaController @Inject() (val pizzaRepository: PizzaRepository)<br/>
            extends Controller {<br/>
            <br/>
            <em>
            &nbsp;&nbsp;val orderForm = Form( mapping (<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"id" -> ignored(None: Option[Long]),<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pizza" -> mapping (<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name" -> nonEmptyText<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)(Pizza.apply)(Pizza.unapply)<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;)(PizzaOrder.apply)(PizzaOrder.unapply)<br/>
            &nbsp;&nbsp;)<br/>
            </em>
            <br/>
            .....<br/>
            <br/>
            }
         </code>
         <p>
            Then we extend the <em>orderPizza</em> method to
            bind the request to this mapping.
         </p>
         <code class="file wide">
            .....<br/>
            <br/>
            def orderPizza = Action { <em>implicit request =&gt;<br/>
            &nbsp;&nbsp;orderForm.bindFromRequest.fold(<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;errors&nbsp;=&gt; BadRequest,<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;order&nbsp;&nbsp;=&gt; Created<br/>
            &nbsp;&nbsp;)</em><br/>
            }<br/>
            <br/>
            .....
         </code>
         <p>
            This can now be tested via a browser by clicking on the <em>order</em>
            buttons on the menu, or directly via <em>curl</em>.
         </p>
         <p>
            This still doesn't really do anything,
            it just returns blank pages as we havent specified a template.
            It only returns the expected <a href="https://httpstatus.es">http error code</a>.
            We could also include the erroneous form in the <em>BadRequest</em> response
            but we are keeping it simple for now.
         </p>
         <code>
            curl --data "{\"wrongfield\"=\"wrongdata\"}" \<br/>
            &nbsp;&nbsp;-H "Content-Type: application/json" \<br/>
            &nbsp;&nbsp;-v http://localhost:9000/order
         </code>
         <p>
            This should not work as wrong field name, and will return amongst others:
         </p>
         <code class="output">&lt; HTTP/1.1 400 Bad Request</code>
         </p>
         <p>
            But this should order a pizza:
         </p>
         <code>
            curl --data "{\"pizza.name\":\"Hawaii\"}" \<br/>
            &nbsp;&nbsp;-H "Content-Type: application/json" \<br/>
            &nbsp;&nbsp;-v http://localhost:9000/order
         </code>
         <code class="output">&lt; HTTP/1.1 201 Created</code>


      </div>

      <div class="paragraph">
         <a name="pizza_confirm"></a>
         <h4>Confirm order</h4>
         <p>
            Ok lets show a more usefull pizza ordered confirmation page,
            than just a blank page with http status code.
         </p>

         <p>
            Lets add a confirmation page route,
            which includes an order id in its path.
         </p>
         <code><em>vi</em> conf/routes</code>
         <code class="file wide">
            # Routes<br/>
            # ~~~~<br/>
            <br/>
            GET&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            controllers.PizzaController.showMenu<br/>
            POST&nbsp;/order&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            controllers.PizzaController.orderPizza<br/>
            <em>GET&nbsp;&nbsp;/order/:orderId
            controllers.PizzaController.showConfirmation(orderId: Long)</em><br/>
            <br/>
            GET&nbsp;&nbsp;/assets/*file&nbsp;&nbsp;
            controllers.Assets.versioned(path="/public", file: Asset)
         </code>
         <p>
            Lets add the <em>showConfirmation</em> method to <em>PizzaController</em>.
            It will try to find the order,
            and either display a confirmation page with it,
            or a blank page with a 404 not found http status code
            if there was no orders found with the supplied id.
         </p>
         <code><em>vi</em> app/controllers/PizzaController.scala</code>
         <code class="file wide">
            .....<br/>
            <br/>
            <em>
            &nbsp;&nbsp;
            def showConfirmation(orderId: Long) = Action.async {<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;
            pizzaRepository.findPizzaOrder(orderId).map{<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            case Some(order) =&gt; Ok(views.html.confirmation(order))<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            case _&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            =&gt; NotFound<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            &nbsp;&nbsp;}<br/>
            </em>
            <br/>
            .....
         </code>
         <p>
            We will need to create the <em>findPizzaOrder</em> method in the pizza repository,
            and hard code its response for now:
         </p>
         <code><em>vi</em> app/repositories/PizzaRepository.scala</code>
         <code class="file wide">
            .....<br/>
            <br/>
            &nbsp;&nbsp;def findPizzaOrder(orderId: Long) = Future { <br/>
            &nbsp;&nbsp;&nbsp;&nbsp;Some(PizzaOrder(Some(orderId), Pizza("Hawaii")))<br/>
            &nbsp;&nbsp;}<br/>
            <br/>
            .....
         </code>
         <p>
            And the view
         </p>
         <code>
            cp app/views/pizzamenu.scala.html \<br/>
            &nbsp;&nbsp;app/views/confirmation.scala.html;<br/>
            <em>vi</em> app/views/confirmation.scala.html
         </code>
         <code class="file wide">
            @(pizzaOrder: PizzaOrder)<br/>
            <br/>
            @main("Pizza order confirmation") {<br/>
            <br/>
               &nbsp;&nbsp;&lt;h1&gt;Pizza ordered!&lt;/h1&gt;<br/>
               <br/>
               &nbsp;&nbsp;&lt;p&gt;<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;You have ordered a &lt;em&gt;@pizzaOrder.pizza.name&lt;/em&gt; pizza!</br>
               &nbsp;&nbsp;&lt;/p&gt;</br>
            <br/>
            }
         </code>
         <p>
            You can test this via:
         </p>
         <code>curl localhost:9000/order/123</code>

         <p>
            Lets add a correct response form the order post we created before,
            and a call to the repositry to simulate storing the order.
            Edit the <em>orderPizza</em> in the pizza controller:
         </p>
         <code><em>vi</em> app/controllers/PizzaController.scala</code>
         <code class="file wide">
            .....<br/>
            <br/>
            &nbsp;&nbsp;def orderPizza = Action<em>.async</em> { implicit request =&gt;<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;orderForm.bindFromRequest.fold(<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errors&nbsp;=&gt;
            <em>Future.successful( BadRequest )</em>,<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order&nbsp;&nbsp;=&gt;
            <em>{<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pizzaRepository.addPizzaOrder(order) map {<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case PizzaOrder(Some(orderId), _) =&gt;<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redirect(routes.PizzaController.showConfirmation(orderId))<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case _ =&gt; InternalServerError("Could not add pizza order")<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</em><br/>
            &nbsp;&nbsp;&nbsp;&nbsp;)<br/>
            &nbsp;&nbsp;}<br/>
            <br/>
            .....
         </code>

         <p>
            And then add the <em>addPizzaOrder</em> to the pizza repository:
         </p>
         <code><em>vi</em> app/repositories/PizzaRepository.scala</code>
         <code class="file wide">
            .....<br/>
            <br/>
            <em>
            &nbsp;&nbsp;def addPizzaOrder(pizzaOrder: PizzaOrder): Future[PizzaOrder] = Future {<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;pizzaOrder.copy(id = Some(123L)<br/>
            &nbsp;&nbsp;}<br/>
            </em>
            <br/>
            .....
         </code>
         <p>
            Test the order pizza call:
         </p>
         <code>
            curl --data "{\"pizza.name\":\"Hawaii\"}" \<br/>
            &nbsp;&nbsp;-H "Content-Type: application/json" \<br/>
            &nbsp;&nbsp;-v http://localhost:9000/order
         </code>
         <p>
            Which response should now include a redirect to the confirmation page:
         </p>
         <code class="output">
            .....<br/>
            <br/>
            &lt; HTTP/1.1 303 See Other<br/>
            &lt; Location: /order/123<br/>
            <br/>
            .....
         </code>

      </div>
   </div>

   <div class="paragraph">
      <a name="persist"></a>
      <h3>Persist</h3>
      <p>
         The hard coded responses in <em>PizzaRepository</em> is not satisfactory.
         Lets add some persistant database support.
      </p>
      <p>
         For this we will use the <a href="http://www.h2database.com">H2 in-memory database</a>.
         Which is ideal unit tests and when developing locally.
      </p>
      <p>
         Then perhaps a docker based <a href="https://www.postgresql.org/">PostgreSQL</a> database when developing and testing
         a larger stack via <a href="https://docs.docker.com/compose/">Docker Compose</a> and in staging environments.
         See my <a href="https://flurdy.com/docs/docker/docker_compose_machine_swarm_cloud.html">Docker machine
            &amp; compose pizzeria howto</a> for an example.
      </p>
      <p>
         When in production it is recommend using proper database instance(s) outside Docker.
         For example clustered <em>PostgreSQL</em>, <a href="aws.amazon.com/rds‚Äé">Amazon RDS</a>,
         <a href="https://cloud.google.com/bigtable/">Google Bigtable</a>, <a href="https://elements.heroku.com/addons/heroku-redis">Redis on Heroku</a>,
         <a href="http://cassandra.apache.org/">Cassandra</a> on <a href="http://mesos.apache.org/">Mesos</a> etc.
         I am on the fence on this one, I understand why due to Docker's ephemeral nature and historic issue with data persistence,
         but I do run many databases in containers, especially less ciritical system...
      </p>
      <p>
         For persistance library this Pizzeria uses <a href="https://www.playframework.com/documentation/2.5.x/ScalaAnorm">Anorm</a>.
         Anorm is very thin wrapper around normal <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> made by the original Play developers themselves.
         A more common framework is <a href="http://slick.lightbend.com/">Slick</a>, and is the default for Play these days.
         Slick is functional relational mapper,
         and often involves more compexity that is needed by too many layers of abstractions.
      </p>
      <p>
         In the project's <em>build.sbt</em> file we will add some dependencies we will need,
         and actually use the <em>jdbc</em> alias we kept earlier.
      </p>
      <code><em>vi</em> build.sbt</code>
      <code class="file wide">
         .....<br/>
         <br/>
         libraryDependencies ++= Seq(<br/>
           &nbsp;&nbsp;jdbc<em>,<br/>
           &nbsp;&nbsp;evolutions,<br/>
           &nbsp;&nbsp;"com.h2database" &nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;"h2"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% "1.4.192",<br/>
           &nbsp;&nbsp;"com.typesafe.play" %% "anorm"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% "2.5.0"<br/>
           </em>
         )<br/>
         <br/>
         .....
      </code>
      <p>
         Play's default main configuration file has evolved into a huge blob
         of configurations.
         But lets remove 99% which is just cruft,
         add some jdbc properties,
         and end up with a config file like this:
      </p>
      <code><em>vi</em> conf/application.conf</code>
      <code class="file wide">
         ## Secret key<br/>
         play.crypto.secret = "<em>changemechangemechangemechangeme</em>"<br/>
         play.crypto.secret=${?APPLICATION_SECRET}<br/>
         <br/>
         <!--
         ## Internationalisation<br/>
         play.i18n {<br/>
           langs = [ "en" ]<br/>
         }<br/>
         <br/>
         -->
         ## Evolutions<br/>
         play.evolutions.db.default.autoApply = true<br/>
         <br/>
         ## JDBC Datasource<br/>
         db.default {<br/>
            &nbsp;&nbsp;driver = org.h2.Driver<br/>
            &nbsp;&nbsp;url = <span class="tiny-code">"jdbc:h2:mem:play;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=FALSE"</span><br/>
            &nbsp;&nbsp;username = sa<br/>
            &nbsp;&nbsp;password = ""<br/>
            &nbsp;&nbsp;logSql = true<br/>
         }¬†¬†
      </code>
      <p>
         Above we have enabled <a href="https://www.playframework.com/documentation/2.5.x/Evolutions">evolutions</a> which lets us create and evolve our database
         schema and data. Our first evolution file creates the initial schema:
      </p>
      <code>
         mkdir -p conf/evolutions/default;<br/>
         touch conf/evolutions/default/1.sql;<br/>
         <em>vi</em> conf/evolutions/default/1.sql
      </code>
      <code class="file wide">
         # Pizzeria schema<br/>
         <br/>
         # --- !Ups<br/>
         <br/>
         CREATE TABLE pizza (<br/>
            &nbsp;&nbsp;id serial NOT NULL,<br/>
            &nbsp;&nbsp;name varchar(128) NOT NULL,<br/>
            &nbsp;&nbsp;PRIMARY KEY (id)<br/>
         );<br/>
         <br/>
         CREATE TABLE pizza_order (<br/>
            &nbsp;&nbsp;id serial NOT NULL,<br/>
            &nbsp;&nbsp;pizza_id int NOT NULL REFERENCES pizza (id),<br/>
            &nbsp;&nbsp;order_date TIMESTAMP NOT NULL DEFAULT NOW(),<br/>
            &nbsp;&nbsp;PRIMARY KEY (id)<br/>
         );<br/>
         <br/>
         <br/>
         # --- !Downs<br/>
         <br/>
         DROP TABLE pizza_order;<br/>
         DROP TABLE pizza;
      </code>

      <p>
         Our <em>PizzaRepository</em> can now be modified to use an actual database.
      </p>
      <code><em>vi</em> app/repositories/PizzaRepository.scala</code>
      <code class="file wide">
         package repositories<br/>
         <br/>
         <em>import anorm._</em><br/>
         <em>import anorm.SqlParser._</em><br/>
         <!-- <em>import anorm.JodaParameterMetaData._</em><br/> -->
         import com.google.inject.ImplementedBy<br/>
         import javax.inject.Inject</br>
         <em>import play.api.db._</em><br/>
         import play.api.libs.concurrent.Execution.Implicits._</br>
         <!-- import org.joda.time.DateTime<br/> -->
         import scala.concurrent.Future<br/>
         import models._<br/>
         <br/>
         <br/>
         @ImplementedBy(classOf[DefaultPizzaRepository])<br/>
         trait PizzaRepository {<br/>
         <br/>
         <em>
         &nbsp;&nbsp;def dbApi: DBApi</br>
         <br/>
         &nbsp;&nbsp;private lazy val db: Database = dbApi.database("default")<br/>
         </em>
         <br/>
         &nbsp;&nbsp;.....<br/>
         <br/>
         }<br/>
         <br/>
         class DefaultPizzaRepository @Inject() (<em>val dbApi: DBApi</em>) extends PizzaRepository
      </code>
      <p>
         Modify the existing trait's methods, starting with <em>findPizzas</em>:
      </p>
      <code class="file wide">
         .....<br/>
         <br/>
         &nbsp;&nbsp;<em>val pizzaParser: RowParser[Pizza] = Macro.namedParser[Pizza]</em><br/>
         <br/>
         &nbsp;&nbsp;def findPizzas(): Future[List[Pizza]] = Future {<br/>
         <em>
            &nbsp;&nbsp;&nbsp;&nbsp;db.withConnection { implicit connection =&gt;<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
               SQL"""<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     select name from pizza
                     order by name<br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  """<br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  .as( pizzaParser.* )<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
         </em>
         &nbsp;&nbsp;}<br/>
         <br/>
         .....
      </code>
      <p>
         And a much more comples <em>addPizzaOrder</em> that uses internal functions
         (mostly as we have not exposed the database id in the <em>Pizza</em> domain model):
      </p>
      <code class="file wide">
         .....<br/>
         <br/>
         &nbsp;&nbsp;def addPizzaOrder(pizzaOrder: PizzaOrder): Future[PizzaOrder] = <em>{<br/>
            <br/>
            &nbsp;&nbsp;&nbsp;&nbsp;def findPizzaId(pizzaName: String) = Future {<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db.withConnection { implicit connection =><br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQL"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        select id from pizza
                        where name = $pizzaName<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     """<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.as( scalar[Long].single )<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;def addOrder(pizzaId: Int) = Future {<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;db.withConnection { implicit connection =><br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQL"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                        insert into pizza_order(pizza_id)
                        values ($pizzaId)<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     """<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     .executeInsert()<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
            <br/>
            &nbsp;&nbsp;&nbsp;&nbsp;for {<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pizzaId <- findPizzaId(pizzaOrder.pizza.name)<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orderId <- addOrder(pizzaId)<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;} yield pizzaOrder.copy( id = orderId )<br/>
         </em>
         &nbsp;&nbsp;}<br/>
         <br/>
         .....
      </code>
      <p>
         And finally <em>findPizzaOrder</em>:
      </p>
      <code class="file wide">
         .....<br/>
         <br/>
         &nbsp;&nbsp;def findPizzaOrder(orderId: Long): Future[Option[PizzaOrder]] = Future {<br/>
         <em>
            &nbsp;&nbsp;&nbsp;&nbsp;db.withConnection { implicit connection =&gt;<br/>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
               SQL"""<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     select p.id as pizza_id, p.name as pizza_name<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     from pizza_order o<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     inner join pizza p on p.id = o.pizza_id<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     where o.id = $orderId<br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  """<br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  .as( ( get[Long]("pizza_id") ~<br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                         get[String]("pizza_name")<br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     ).singleOpt )<br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  .map{ case pizzaId ~ pizzaName =&gt;<br/>
                     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                     PizzaOrder( Some(orderId), Pizza(pizzaName) )<br/>
                  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
                  }<br/>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br/>
         </em>
         &nbsp;&nbsp;}<br/>
         <br/>
         .....
      </code>
      <p>
         Lets add the default pizzas to the menu:
      </p>
      <code>
         touch conf/evolutions/default/2.sql;<br/>
         <em>vi</em> conf/evolutions/default/2.sql
      </code>
      <code class="file wide">
         # Pizzeria Menu<br/>
         <br/>
         # --- !Ups<br/>
         <br/>
         INSERT INTO pizza (name) values<br/>
         &nbsp;&nbsp;('Margherita'),<br/>
         &nbsp;&nbsp;('Hawaii'),<br/>
         &nbsp;&nbsp;('Quattro Stagioni'),<br/>
         &nbsp;&nbsp;('Pepperoni');<br/>
         <br/>
         <br/>
         # --- !Downs<br/>
         <br/>
         DELETE FROM pizza;
      </code>
      <p>
         We can now test the full flow with persisted data.
      </p>
      <code>sbt run</code>
      <code>curl localhost:9000</code>
      <p>
         This should show the extended menu.
      </p>
      <code>
         curl --data "{\"pizza.name\":\"Margherita\"}" \<br/>
         &nbsp;&nbsp;-H "Content-Type: application/json" \<br/>
         &nbsp;&nbsp;-v localhost:9000/order/code
      </code>
      <p>
         This should show a redirect to confimation page.
         And if we <em>GET</em> that it should show we ordered a <em>Margherita</em>.
      </p>
      <code>curl localhost:9000/order/1</code>
      <p>
         Build a Docker image of our finished Pizzeria service.
         And tag it.
      </p>
      <code>
         docker build -t pizzeria .;<br/>
         docker tag pizzeria:latest pizzeria:1.0
      </code>
   </div>

   <div class="paragraph">
      <a name="docker_cloud"></a>
      <h3>Docker Cloud</h3>
      <p>
         <a href="https://cloud.docker.com/">Docker Cloud</a> is a handy way to manage your public docker containers.
         It enables you to easily build and host your images.
         It lets you orchestrate and deploy your container stacks.
         And monitor and scale as appropriate.
      </p>
      <p>
         Docker Cloud does not actually host your actual running containers.
         Hosting is still done with normal
         <a href="https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29">IAAS</a> cloud providers.
         Such as <a href="http://aws.amazon.com">Amazon AWS</a>, etc.
         Docker Cloud instead manages the containers on these instances for you.
         It can directly create instances for you on some of the <em>IAAS</em> providers,
         or you can connect an existing node to Docker Cloud
         by installing an agent service.
         You can also spread your containers horizontally across nodes on different <em>IAAS</em> providers.
      </p>
      <p>
         There is a reasonable free tier that lets your experiment and run quite a few containers for free.
         (As I am <a href="https://en.wikipedia.org/wiki/Grandfather_clause">grand-fathered</a> in as
         a user of Docker Cloud's predecessor, <a href="https://blog.docker.com/2015/10/docker-acquires-tutum/">Tutum</a> so my free tier is slightly more generous).
         Combine this with the free tiers at many IAAS providers you can experiment for quite some time totally free.
      </p>

      <a name="docker_cloud_repository"></a>
      <div class="paragraph">
         <h4>Repository</h4>
         <p>
            We need to store the Docker image of our Pizzeria service, so we need a <a href="https://docs.docker.com/registry/">Docker registry</a>
            There are many providers, <a href="https://quay.io/">Quay.io</a>, <a href="https://aws.amazon.com/ecr/">Amazon EC2 Container Registry</a>,
            <a href="https://cloud.google.com/container-registry/">Google Platform Container Registry</a>, etc.
            You can even host a registry yourself inside a container.
            But for our pizzeria we will use the <a href="https://hub.docker.com/">Docker Hub</a>.
         </p>
         <p>
            Go to <a href="https://hub.docker.com/">Docker Hub</a>, log in with your <em>Docker id</em> or sign up.
            Create a new repository for the pizzeria service.
         </p>
         <p>
            Lets push up our local Docker image to the public one you just created.
         </p>
         <code>docker push <em>yourUsername</em>/<em>pizzeria</em>:latest</code>
      </div>

      <a name="docker_cloud_node"></a>
      <div class="paragraph">
         <h4>Node(s)</h4>
         <p>
				As part of the excellent <a href="https://docs.docker.com/docker-cloud/getting-started/intro_cloud/">Docker Cloud's own intro to itself</a>
				we will start by <a href="https://docs.docker.com/docker-cloud/getting-started/connect-infra/">integrating your IAAS / cloud service provider</a>.
            At the time of writing, December 2016, Docker Cloud supports out of the box <em>AWS</em>,
            <a href="http://www.digitalocean.com">Digital Ocean</a>,
            <a href="https://azure.microsoft.com">Microsoft Azure</a>,
            <a href="http://www.softlayer.com">SoftLayer</a> and
            <a href="https://www.packet.net/">Packet.net</a>.
            It does not yet support <a href="http://cloud.google.com">Google Cloud</a>  directly.
         </p>
         <p>
            <em>DigitalOcean</em> is the easiest to integrate with.
            <em>Amazon AWS</em> I would guess is the most popular as many will already have a presence there.
            I prefer <em>Google Cloud</em> as provider,
            via the <a href="https://docs.docker.com/docker-cloud/infrastructure/byoh/">Bring Your Own Node</a> feature.
         </p>
         <p>
            <a href="https://docs.docker.com/docker-cloud/getting-started/your_first_node/">Create a node</a> or two.
            Keep in mind the pizzeria service is a JVM based image so will be memory hungry,
            and for now compute shy. So the <em>t2.nano</em> and <em>t2.micro</em> instances on AWS will be too small
            where
            as a $20 instance on DigitalOcean or a <em>t2.small</em> instance on AWS is a good start, and <em>R4</em> instances better suited later on.
            For example I mostly use 6.5GB with 1 cpu <a href="https://cloud.google.com/custom-machine-types/">custom instances</a> on Google Cloud to host 4-5 containers per node.
         </p>
         <p>
            <strong>Note unless you are within the free tier on your IAAS, the node choices will cost you money.</strong>
         </p>
      </div>
      <a name="docker_cloud_service"></a>
      <div class="paragraph">
         <h4>Service</h4>
         <p>
            <a href="https://docs.docker.com/docker-cloud/getting-started/your_first_service/">Create a service</a>,
            which is basically your application. There are lots of options you dont need to worry about right now but essentialy:
         </p>
         <ul>
            <li>Specify the docker image and version to use (the latest of the pizzeria repository)</li>
            <li>Think of a nickname for the service (pizzeria)</li>
            <li>Set how many containers to scale across (1 for now)</li>
            <li>Toggle whether to auto deploy updates to the image tag (yes)</li>
            <li>
               Decide whether to expose a port as published, and if that is dynamic or static.<br/>
               (We will publish port 9010 for our pizzeria).
            </li>
         </ul>
      </div>
      <a name="docker_cloud_deploy"></a>
      <div class="paragraph">
         <h4>Deploy</h4>
         <p>
            Once the service is configured you press the
            <a href="https://docs.docker.com/docker-cloud/getting-started/your_first_service/#/create-and-deploy">Create &amp; Deploy</a> button.
         </p>
         <p>
            If that works, then you should be forwarded to the final screen where a summary of the service is shown.
            Note the <em>Endpoints</em> section, where you shold have a <em>Service</em> and a <em>Container</em> endpoints.
            The service endpoint should look something like:
         </p>
         <code class="output">tcp://pizzeria.12abcd34.svc.dockerapp.io:9010</a></code>
         <p>
            The service endpoint is clickable, but change the protocol from <em>tcp</em> to <em>http</em>.
         </p>
         <p>
            Note: If you plan to add SSL to your apps by following my
            <a href="https://flurdy.com/docs/letsencrypt/nginx.html">Let's Encrypt with Nginx</a>,
            then this service endpoint is the one you need to proxy to.
         </p>
      </div>
      <a name="docker_cloud_stack"></a>
      <div class="paragraph">
         <h4>Stack</h4>
         <p>
            <a href="https://docs.docker.com/docker-cloud/getting-started/deploy-app/11_service_stacks/">Stacks</a>
            are not need in this pizzeria example.
            But if you were to separate the service into e.g. a back-end, front-end and database,
            like <a href="http://flurdy.com/docs/docker/docker_compose_machine_swarm_cloud.html">my docker compose based example</a>,
            then <em>Stacks</em> is where you define the separate services within Docker Cloud.
         </p>
      </div>
   </div>

   <div class="paragraph">
      <a name="alt"></a>
      <h3>Alternatives</h3>

      <div class="paragraph">
         <a name="spray"></a>
         <h4>Spray / Akka HTTP</h4>
         <p>
            <a href="http://spray.io">Spray</a> and its successor <a href="https://github.com/akka/akka-http">Akka HTTP</a>
            are alternatives to Play.
            It is a good choice for a service without UI such as the backend in <a href="http://flurdy.com/docs/docker/docker_compose_machine_swarm_cloud.html">my docker compose example</a>.
         </p>
      </div>

      <div class="paragraph">
         <a name="heroku"></a>
         <h4>Heroku</h4>
         <p>
            <a href="http://heroku.com/">Heroku</a> is a <a href="https://en.wikipedia.org/wiki/Platform_as_a_service">PAAS</a>.
            And is the smoothest and quiest way to deploy a pizzeria service to a cloud/hosting provider.
            I love Heroku, and run many applications with it, but it is not perfect.
            They do support a Docker build flow, but mostly you do not use Docker with Heroku.
            Instead you push your code (via <a href="https://git-scm.com/">Git</a> <em>remote</em>)
            and use their build flow to generate and host their own containers.
         </p>
      </div>

      <div class="paragraph">
         <a name="amazon_ecs"></a>
         <h4>Amazon ECS</h4>
         <p>
            The <a href="https://aws.amazon.com/ecs/">EC2 Container Service</a>
            is a full and extensive Docker container service.
         </p>
      </div>

      <div class="paragraph">
         <a name="google_gke"></a>
         <h4>Google Container Engine</h4>
         <p>
            The <a href="https://cloud.google.com/container-engine/">Container Engine</a>
            is an extensive Docker container service.
            It is a commercial offering that uses <a href="http://kubernetes.io/">Kubernetes</a> clusters.
         </p>
      </div>

      <div class="paragraph">
         <a name="tectonic"></a>
         <h4>Tectonic</h4>
         <p>
            <a href="https://tectonic.com">Tectonic</a> is a commercial offering by
            <a href="http://coreos.com">CoreOS</a> that uses
            <a href="http://kubernetes.io/">Kubernetes</a> clusters.
         </p>
      </div>

      <div class="paragraph">
         <a name="cloud66"></a>
         <h4>Cloud 66</h4>
         <p>
            <a href="https://cloud66.com">Cloud 66</a> offer Docker management of containers
            on other IAAS providers.
         </p>
      </div>

      <div class="paragraph">
         <a name="triton"></a>
         <h4>Triton</h4>
         <p>
            <a href="https://www.joyent.com/triton">Triton</a> by
            <a href="https://www.joyent.com">Joyent</a> offer containers as a service.
         </p>
      </div>

      <div class="paragraph">
         <a name="docker_machine"></a>
         <h4>Docker Machine</h4>
         <p>
            At a lower level <a href="https://www.docker.com/products/docker-machine">Docker Machine</a>
            lets you create instances in cloud providers.
            You can then manually deploy your containers to it.
            You can also scale horizontally with <a href="https://www.docker.com/products/docker-swarm">Docker Swarm</a>.
         </p>
      </div>

      <div class="paragraph">
         <a name="docker_aws"></a>
         <h4>Docker for AWS</h4>
         <p>
            A recently annouced product you can also deploy containers directly to AWS with
            <a href="https://beta.docker.com/docs/aws/">Docker for AWS</a>.
         </p>
      </div>
   </div>

   <div class="paragraph">
      <a name="contact"></a>
      <h3>Feedback</h3>
      <p>
         Please <a href="http://github.com/flurdy/flurdy.com-docs">fork and send a pull request</a> for to correct any typos, or useful additions.
      </p>
      <p>
         <a href="http://shirts.flurdy.com">Buy a t-shirt</a> if you found this guide useful.
         <a href="http://www.eray.uk">Hire me</a> for short term advice or long term consultancy.
      </p>
      <p>
         Otherwise <a href="/contact">contact me</a>.
         Especially for things factually incorrect.
         Apologies for procrastinated replies.
      </p>
   </div>

   <div class="paragraph">
      <a name="references"></a>
      <h3>References</h3>
      <p>
      </p>
      <ul>
         <li><a href="http://github.com/flurdy/pizzeria">Pizzeria project</a></li>
         <li><a href="http://www.scala-lang.org">Scala</a>
					<a href="https://en.wikipedia.org/wiki/Scala_(programming_language)"><sup>wiki</sup></a></li>
         <li><a href="https://www.playframework.com">Play Framework</a>
					<a href="https://en.wikipedia.org/wiki/play_framework"><sup>wiki</sup></a></li>
         <li><a href="https://www.docker.com">Docker</a>
					<a href="https://en.wikipedia.org/wiki/Docker_(software)"><sup>wiki</sup></a></li>
         <li><a href="http://cloud.docker.com">Docker Cloud</a></li>
         <li><a href="http://cloud.google.com">Google Cloud</a>
					<a href="https://en.wikipedia.org/wiki/Google_Cloud_Platform"><sup>wiki</sup></a></li>
         <li><a href="http://aws.amazon.com">Amazon AWS</a>
					<a href="https://en.wikipedia.org/wiki/Amazon_Web_Services"><sup>wiki</sup></a></li>
         <li><a href="http://www.heroku.com">Heroku</a>
					<a href="https://en.wikipedia.org/wiki/heroku"><sup>wiki</sup></a></li>
   </div>

</div>

         <footer>
            <nav>
               <ul class="horizontal">
                  <li><a href="http://flurdy.com">flurdy</a></li>
                  <li><a href="http://twitter.com/flurdy">@flurdy</a></li>
                  <li><a href="http://blog.flurdy.com">blog</a></li>
                  <li><a href="http://shirts.flurdy.com">shirts</a></li>
                  <li><a href="http://www.eray.uk">hire</a></li>
                  <li><a href="/docs/">more docs</a></li>
               </ul>
            </nav>
         </footer>
      </div>
   </div>
   <link href='//fonts.googleapis.com/css?family=Michroma' rel='stylesheet' type='text/css' />

</body>
</html>
